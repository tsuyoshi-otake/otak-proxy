# Requirements Document

## Introduction

このドキュメントは、otak-proxy拡張機能のextension.tsファイル（1335行）を、保守性と可読性を向上させるために複数の小さなモジュールに分割するリファクタリングの要件を定義します。

## Glossary

- **Extension**: VSCode拡張機能のメインエントリーポイント
- **ProxyState**: プロキシの現在の状態（モード、URL、設定状態など）を保持するオブジェクト
- **ConfigManager**: Git、VSCode、npmの設定を管理するクラス群
- **Command**: VSCodeコマンドとして登録される関数
- **StatusBar**: VSCodeのステータスバーに表示されるUI要素

## Requirements

### Requirement 1

**User Story:** 開発者として、extension.tsファイルを理解しやすい小さなモジュールに分割したい。そうすることで、コードの保守性と可読性が向上する。

#### Acceptance Criteria

1. WHEN extension.tsファイルが分割される THEN システムは各モジュールが単一責任の原則に従うべき
2. WHEN 新しいモジュール構造が作成される THEN システムは各ファイルが300行以下であるべき
3. WHEN リファクタリングが完了する THEN システムはすべての既存テストが引き続き合格するべき
4. WHEN モジュールが分割される THEN システムは循環依存を持たないべき
5. WHEN 新しい構造が作成される THEN システムは明確なフォルダ階層を持つべき

### Requirement 2

**User Story:** 開発者として、コマンド関連のコードを独立したモジュールに分離したい。そうすることで、コマンドの追加や変更が容易になる。

#### Acceptance Criteria

1. WHEN コマンドが分離される THEN システムは各コマンドを独立した関数として定義するべき
2. WHEN コマンドモジュールが作成される THEN システムはコマンド登録ロジックを一箇所に集約するべき
3. WHEN コマンドが実行される THEN システムは共通のエラーハンドリングパターンを適用するべき
4. WHEN 新しいコマンドが追加される THEN システムは既存のコマンドに影響を与えないべき

### Requirement 3

**User Story:** 開発者として、状態管理ロジックを独立したモジュールに分離したい。そうすることで、状態の読み書きが一貫性を持つ。

#### Acceptance Criteria

1. WHEN 状態管理が分離される THEN システムはProxyStateの読み書きを専用クラスで管理するべき
2. WHEN 状態が更新される THEN システムはin-memoryフォールバックを自動的に処理するべき
3. WHEN 状態が読み込まれる THEN システムは古い設定からの移行を透過的に処理するべき
4. WHEN 状態管理クラスが作成される THEN システムは状態の検証ロジックを含むべき

### Requirement 4

**User Story:** 開発者として、プロキシ設定適用ロジックを独立したモジュールに分離したい。そうすることで、設定適用の流れが明確になる。

#### Acceptance Criteria

1. WHEN 設定適用ロジックが分離される THEN システムは各ConfigManagerへの呼び出しを統一的に扱うべき
2. WHEN プロキシが有効化される THEN システムはバリデーション、適用、エラー集約を順次実行するべき
3. WHEN プロキシが無効化される THEN システムはすべてのConfigManagerのunsetを呼び出すべき
4. WHEN 設定適用が失敗する THEN システムはErrorAggregatorを使用してエラーを収集するべき

### Requirement 5

**User Story:** 開発者として、ステータスバー更新ロジックを独立したモジュールに分離したい。そうすることで、UI表示ロジックが明確になる。

#### Acceptance Criteria

1. WHEN ステータスバーロジックが分離される THEN システムはステータスバーの作成と更新を専用クラスで管理するべき
2. WHEN ステータスバーが更新される THEN システムは現在のProxyStateに基づいてテキストとツールチップを生成するべき
3. WHEN ツールチップが生成される THEN システムはコマンドリンクの検証を実行するべき
4. WHEN ステータスバーが表示される THEN システムはi18n対応のテキストを使用するべき

### Requirement 6

**User Story:** 開発者として、重複したコードを共通ユーティリティに抽出したい。そうすることで、コードの重複が減少し保守性が向上する。

#### Acceptance Criteria

1. WHEN 重複コードが特定される THEN システムは共通パターンをユーティリティ関数に抽出するべき
2. WHEN バリデーションと設定適用が繰り返される THEN システムは共通関数を使用するべき
3. WHEN エラーハンドリングが繰り返される THEN システムは共通のエラーハンドリングラッパーを使用するべき
4. WHEN ConfigManager呼び出しが繰り返される THEN システムは統一的なインターフェースを使用するべき

### Requirement 7

**User Story:** 開発者として、テストの実行速度を向上させたい。そうすることで、開発サイクルが高速化される。

#### Acceptance Criteria

1. WHEN プロパティベーステストが実行される THEN システムは開発モードでは実行回数を削減するべき
2. WHEN 外部コマンド依存のテストが実行される THEN システムは可能な限りモックを使用するべき
3. WHEN テストスイートが実行される THEN システムは独立したテストを並列実行できるべき
4. WHEN テストが失敗する THEN システムは高速にフィードバックを提供するべき
5. WHEN 統合テストが実行される THEN システムは必要な場合のみ実際のコマンドを実行するべき
